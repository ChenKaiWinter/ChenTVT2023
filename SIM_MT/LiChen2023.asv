% "Signal Processing and Beamforming Optimization for Full-Duplex NOMA Enabled Integrated Sensing and Communication" 
% - Kai Chen et. al.
% Kai Chen, 10/07/2023

%% Set up the System -- Multi Target
K = 2; DUE_dis = [128 128]; DUE_agl = [-50 50];           % K: number of DUE
M = 4; UUE_dis = [8 16 32 64]; UUE_agl = [-70 -30 40 60]; % M: number of UUE
L = 3; tgt_agl = [-10 0 20];                              % L: number of tgt

% N_t = 16; % tranmit antennas number
% N_r = 16; % receive antennas number
N_t = 16; % tranmit antennas number
N_r = 16; % receive antennas number

P_t_dB = 20; P_t = 10^(P_t_dB/10); % transmit power at BS
P_u_dB = 10; P_u = 10^(P_u_dB/10); % transmit power at UUE

n_d_dB = -80; n_d = 10^(n_d_dB/10);          % downlink noise power sigma_d
n_u_dB = -80; n_u = 10^(n_u_dB/10);          % uplink noise power sigma_u
n_dB = -80; n = 10^(n_dB/10);                % uplink noise power sigma after vectorization
% n_l = [1 1 1];                             % complex amplitude variance |alpha_l|^2
n_l = [10^(-30/10) 10^(-30/10) 10^(-30/10)]; % complex amplitude variance |alpha_l|^2

f_c = 5e9; c = 3e8; lambda = c/f_c; spacing = lambda/2; % half wavelength
TxAntLoc = spacing*[0:N_t-1];                           % transmit antennas spatial position
RxAntLoc = spacing*[0:N_r-1];                           % receive antennas spatial position
D = 181; angleSpace = linspace(-pi/2, pi/2, D); angleSpaceDeg = linspace(-90, 90, D);

% transmit antennas steering vecter all angle
% a_tx = zeros(N_t, length(angleSpace));
% for i = 1:N_t
%     a_tx(i,:) = exp((1j * 2 * pi * TxAntLoc(i) / lambda) .* (sin(angleSpace)));
% end
a_tx_1 = zeros(N_t, length(angleSpace));
a_tx_2 = zeros(N_t, length(angleSpace));
a_tx_tgt_1 = zeros(N_t, length(angleSpace));
a_tx_tgt_2 = zeros(N_t, length(angleSpace));
a_tx_tgt_3 = zeros(N_t, length(angleSpace));
for i = 1:N_t
    a_tx_1 = a_tx_1 + exp((1j * 2 * pi * TxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*DUE_agl(1)/180)));
    a_tx_2 = a_tx_2 + exp((1j * 2 * pi * TxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*DUE_agl(2)/180)));
    a_tx_tgt_1 = a_tx_tgt_1 + exp((1j * 2 * pi * TxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*tgt_agl(1)/180)));
    a_tx_tgt_2 = a_tx_tgt_2 + exp((1j * 2 * pi * TxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*tgt_agl(2)/180)));
    a_tx_tgt_3 = a_tx_tgt_3 + exp((1j * 2 * pi * TxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*tgt_agl(3)/180)));
end
a_tx=(a_tx_1+a_tx_2+a_tx_tgt_1+a_tx_tgt_2+a_tx_tgt_3)/5;

% receive antennas steering vector all angle
% a_rx = zeros(N_r, length(angleSpace));
% for i=1:N_r
%     a_rx(i,:) = exp((1j * 2 * pi * RxAntLoc(i) / lambda) .* (sin(angleSpace)));
% end
% comm
a_rx_1 = zeros(N_r, length(angleSpace));
a_rx_2 = zeros(N_r, length(angleSpace));
a_rx_3 = zeros(N_r, length(angleSpace));
a_rx_4 = zeros(N_r, length(angleSpace));
a_rx_tgt_1 = zeros(N_r, length(angleSpace));
a_rx_tgt_2 = zeros(N_r, length(angleSpace));
a_rx_tgt_3 = zeros(N_r, length(angleSpace));
for i=1:N_r
    a_rx_1 = a_rx_1 + exp((1j * 2 * pi * RxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*UUE_agl(1)/180)));
    a_rx_2 = a_rx_2 + exp((1j * 2 * pi * RxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*UUE_agl(2)/180)));
    a_rx_3 = a_rx_3 + exp((1j * 2 * pi * RxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*UUE_agl(3)/180)));
    a_rx_4 = a_rx_4 + exp((1j * 2 * pi * RxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*UUE_agl(4)/180)));
    a_rx_tgt_1 = a_rx_tgt_1 + exp((1j * 2 * pi * TxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*tgt_agl(1)/180)));
    a_rx_tgt_2 = a_rx_tgt_2 + exp((1j * 2 * pi * TxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*tgt_agl(2)/180)));
    a_rx_tgt_3 = a_rx_tgt_3 + exp((1j * 2 * pi * TxAntLoc(i) / lambda) .* (sin(angleSpace)-sin(pi*tgt_agl(3)/180)));
end
a_rx=(a_rx_1+a_rx_2+a_rx_3+a_rx_4+a_rx_tgt_1+a_rx_tgt_2+a_rx_tgt_3)/7;
% sensing


% guide steering vector
b = zeros(N_t,L); % transmit steering vecter
for l = 1:L
    b(:,l) = a_tx(:,90+tgt_agl(l));
end
a = zeros(N_r,L); % receive steering vecter
for l = 1:L
    a(:,l) = a_rx(:,90+tgt_agl(l));
end

% generate the user's coordinates
DUE_loc_x = zeros(1, K);
DUE_loc_y = zeros(1, K);
UUE_loc_x = zeros(1, M);
UUE_loc_y = zeros(1, M);
for k =1:K
    DUE_loc_x(k) = DUE_dis(k)*cos(DUE_agl(k));
end
for k =1:K
    DUE_loc_y(k) = DUE_dis(k)*sin(DUE_agl(k));
end
DUE_loc = [DUE_loc_x;DUE_loc_y]; % location of DUE
for m =1:M
    UUE_loc_x(m) = UUE_dis(m)*cos(UUE_agl(m));
end
for m =1:M
    UUE_loc_y(m) = UUE_dis(m)*sin(UUE_agl(m));
end
UUE_loc = [UUE_loc_x;UUE_loc_y]; % location of UUE

% distance between UUE and DUE
D_U_dis = zeros(M,K);
for m = 1:M
    for k = 1:K
        D_U_dis(m,k) = gen_dis(UUE_loc(:,m),DUE_loc(:,k));
    end
end

%% Algorithm
% w_intial
w_0 = sqrt(P_t/(2*N_t^2))*randn(N_t^2, 1)+sqrt(P_t/(2*N_t^2))*1i*randn(N_t^2, 1);
save('mat\w_0.mat','w_0');
load('mat\w_0.mat'); % get the inital power

% ch_intial
G_dB = 10; % Rician factor
beta = 3.8;
[h_d, h_u, g, H_RSI] = gen_h_rci(G_dB, beta, a_tx, a_rx, N_t, N_r, K, M, ...
    DUE_agl, UUE_agl, DUE_dis, UUE_dis, D_U_dis); % h_d, h_u, g are chanel matrix
save('mat\ch.mat','h_d','h_u','g','H_RSI'); % save the channel
load('mat\ch.mat'); % get the inital chanel

% generate the matrix that I need
w_k_1=w_0; % w^(k-1)
[C, J_i, R_e, R_n, tilde_R_e, tilde_R_n, R_k, sum_R_i] = gen_mat(N_r, N_t, K, L, H_RSI, a, b, n_l, w_k_1);

% begin
e = 0.001; iter = 1; maxSINR = 0;

%% Iterative Algorithm
% IBS inital
zeta_l=0;
zeta_u=1e4;
zeta=(zeta_l+zeta_u)/2;

while true

% Iter I - u_l: the sensing beamforming vector
u_l=zeros(N_r*N_t,L);
for l=1:L
    u_l(:,l)=( (tilde_R_e(:,:,l)+tilde_R_n+n*eye(N_r*N_t))^(-1)*kron(eye(N_t),C(:,:,l))*w_k_1 )...
    /(w_k_1'*kron(eye(N_t),C(:,:,l))'*(tilde_R_e(:,:,l)+tilde_R_n+n*eye(N_r*N_t))^(-1)*kron(eye(N_t),C(:,:,l))*w_k_1);
end

gamma_l_k_1=zeros(1,L);
for l=1:L
    gamma_l_k_1(l)=(n_l(l)*(abs(u_l(:,l)'*kron(eye(N_t),C(:,:,l))*w_k_1)^2))/...
    norm(u_l(:,l)'*(tilde_R_e(:,:,l)+tilde_R_n+n.*eye(N_r*N_t))*u_l(:,l));
end

% Iter II - v_m: the uplink receive communication beamforming vector
P_u_H_u=zeros(N_r,N_r,M);
for tilde_m=1:M
    if tilde_m==M
        P_u_H_u(:,:,tilde_m)=zeros(N_r,N_r);
    end
    for m=tilde_m+1:M
        P_u_H_u(:,:,tilde_m)=P_u_H_u(:,:,tilde_m)+P_u*(h_u(:,m)*h_u(:,m)');
    end
end
v_m=zeros(N_r,M);
for m=1:M
    v_m(:,m)=sqrt(P_u)*( (P_u_H_u(:,:,m)+R_e+R_n+n_u*eye(N_r))^(-1) )*h_u(:,m);
end

% Iter III - w: the transmit beamforming vector
%%%%%%constraint(59b)%%%%%%
% O_l
O=zeros(N_t^2,N_t^2,L);
for l=1:l
    O(:,:,l)=n_l(l)*(kron(eye(N_t),C(:,:,l))'*(u_l(:,l)*u_l(:,l)')*kron(eye(N_t),C(:,:,l)));
end
% tilde_Q_l
tilde_Q=zeros(N_t^2,N_t^2,L);
for tgt_index=1:L
    n_l_temp=n_l;
    n_l_temp(tgt_index)=[];
    C_temp=C;
    C_temp(:,:,tgt_index)=[];
    Q_part_1=zeros(N_r*N_t,N_r*N_t);
    for l=1:L-1
        Q_part_1=Q_part_1+n_l_temp(l)*kron(eye(N_t),C(:,:,l))'*(u_l(:,1)*u_l(:,1)')*kron(eye(N_t),C(:,:,l));
    end
    tilde_Q(:,:,tgt_index)=Q_part_1+kron(eye(N_t),H_RSI)'*(u_l(:,tgt_index)*u_l(:,tgt_index)')*kron(eye(N_t),H_RSI)...
        +n.*(u_l(:,l)'*u_l(:,l))/P_t;
end
%%%%%%constraint(59c)%%%%%%
% scalar
gamma_k_d=[18 18];
r_d=[0.2 0.2];
omega_1=2; % {omega}>=0
omega_2=2; % So what?
%%%%%%constraint(59d)%%%%%%
% P_m
P_m_part_1=zeros(N_t^2,N_t^2,M);
for m=1:M
    for i=1:N_t
        P_m_part_1(:,:,m)=J_i(i)'*H_RSI'*v_m(:,m)*v_m(:,m)'*H_RSI*J_i(i);
    end
end
P_m_part_2=zeros(N_t^2,N_t^2,M);
for m=1:M
    for i=1:N_t
        for l=1:L
            P_m_part_2(:,:,M)=n_l(l).*J_i(i)'*C(:,:,l)'*v_m(:,m)*v_m(:,m)'*C(:,:,l)*J_i(i);
        end
    end
end
P_m=zeros(N_t^2,N_t^2,M);
for m=1:M
    P_m(:,:,m)=P_m_part_1(:,:,m)+P_m_part_2(:,:,m);
end
% scalar
gamma_m_u=[10 8 6 4]; 
r_m_u=[0.2 0.2 0.2 0.2];
P_u_V_H=zeros(1,M);
for tilde_m=1:M
    if tilde_m==M
        P_u_V_H(:,tilde_m)=0;
    end
    for m=tilde_m+1:M
        P_u_V_H(:,tilde_m)=P_u_V_H(:,tilde_m)+P_u*( abs(v_m(:,m)'*h_u(:,tilde_m))+r_m_u(tilde_m)*norm(v_m(:,m)) )^2;
    end
end
tilde_c_m_u=zeros(1,M);
for m=1:M
    tilde_c_m_u(:,m)=( P_u*( abs(v_m(:,m)'*h_u(:,m))^2+r_m_u(m)*norm(v_m(:,m)) ) )/gamma_m_u(m)-P_u_V_H(:,m)-n_u*(v_m(:,m)'*v_m(:,m));
end

% use CVX to solve Iter III
cvx_begin SDP quiet
cvx_precision high
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%variable%%%
variable tilde_W(N_t^2, N_t^2) hermitian
%%%%OBJ_FX%%%%
% This is a problem with no objective function
%%constraint%%
subject to
%%%%%%constraint(59b)%%%%%%
for l=1:L
    real(trace(O(:,:,l)*tilde_W))-zeta*(real(trace(tilde_Q(:,:,l)*tilde_W)))>=0;
end
%%%%%%constraint(59c)%%%%%%
Ih_1=[eye(N_t);h_d(:,1)'];
Ih_2=[eye(N_t);h_d(:,2)'];
Ih_1*( (1+1/gamma_k_d(1))*R_k(:,:,1)-sum_R_i )*Ih_1'+...
    [omega_1*eye(N_t),zeros(N_t,1);zeros(N_t,1)',-P_u.*norm(g(:,1))-n_d-omega_1*r_d(1)^2]>=0;
Ih_2*( (1+1/gamma_k_d(2))*R_k(:,:,1)-sum_R_i )*Ih_2'+...
    [omega_2*eye(N_t),zeros(N_t,1);zeros(N_t,1)',-P_u.*norm(g(:,2))-n_d-omega_2*r_d(2)^2]>=0;
%%%%%%constraint(59d)%%%%%%
for m=1:M
    tilde_c_m_u(m)-real(trace(P_m(:,:,m)*tilde_W))>=0;
end
%%%%%%constraint(59e)%%%%%%
trace(tilde_W)<=P_t;
%%%%%%%%%%%%%%%%%%%%%%%%%%%
tilde_W==semidefinite(N_t^2);
cvx_end

%%%solution%%%
% Gaussian randomization -- do randomization to get our feasible beamforming vectors w_cand
nRand = 100;
w_rand = zeros(N_t^2, nRand);

% generate and scale to meet power constraints and other constraints
for L_rand = 1:nRand
    % generate nRand
    tmp(:,L_rand) = mvnrnd(zeros(N_t^2,1),tilde_W) + 1i*mvnrnd(zeros(N_t^2,1),tilde_W);
    % scale them so it adheres to power constraint
    w_rand(:,L_rand) = sqrt(trace(tilde_W))*tmp(:,L_rand)/sqrt(tmp(:,L_rand)'*tmp(:,L_rand));
end

for i=1:nRand
    % find the min SINR and corresponding vector
    minSINR=(n_l(1).*norm(u_l(:,1)'*kron(eye(N_t),C(:,:,tgt_index))*w_rand(:,i))^2)/...
            norm( u_l(:,1)'*(tilde_R_e(:,:,1)+tilde_R_n+n.*eye(N_r*N_t))*u_l(:,1) );
    minu_l=u_l(:,1);
    if( ((n_l(2).*norm(u_l(:,2)'*kron(eye(N_t),C(:,:,tgt_index))*w_rand(:,i))^2)/...
            norm(u_l(:,2)'*(tilde_R_e(:,:,2)+tilde_R_n+n.*eye(N_r*N_t))*u_l(:,2)))<minSINR )
        minSINR=((n_l(2).*norm(u_l(:,2)'*kron(eye(N_t),C(:,:,tgt_index))*w_rand(:,i))^2)/...
            norm(u_l(:,2)'*(tilde_R_e(:,:,2)+tilde_R_n+n.*eye(N_r*N_t))*u_l(:,2)));
        minu_l=u_l(:,2);
    end
    if( ((n_l(3).*norm(u_l(:,3)'*kron(eye(N_t),C(:,:,tgt_index))*w_rand(:,i))^2)/...
            norm(u_l(:,3)'*(tilde_R_e(:,:,3)+tilde_R_n+n.*eye(N_r*N_t))*u_l(:,3)))<minSINR )
        minSINR=((n_l(2).*norm(u_l(:,2)'*kron(eye(N_t),C(:,:,tgt_index))*w_rand(:,i))^2)/...
            norm(u_l(:,2)'*(tilde_R_e(:,:,3)+tilde_R_n+n.*eye(N_r*N_t))*u_l(:,3)));
        minu_l=u_l(:,2);
    end
    if minSINR>maxSINR 
        maxSINR=minSINR;
        w_opt=w_rand(:,i);
    end
end

if ( (strcmp(cvx_status,'Solved')==1)||(strcmp(cvx_status,'Inaccurate/Solved')==1) ) % if there is a solution
    zeta_l=zeta;
    zeta=(zeta_l+zeta_u)/2;
    fprintf('Solved, Upward, zeta=%.5f, zeta_l=zeta, (Iter: zeta_l=%.5f, zeta_u=%.5f, zeta_u-zeta_l=%.5f)\n',zeta,zeta_l,zeta_u,zeta_u-zeta_l);
    if (zeta_u-zeta_l<0.1)
        break;
    end
else
    zeta_u=zeta;
    zeta=(zeta_l+zeta_u)/2;
    fprintf('Unresolved, Downward, zeta=%.5f, zeta_u=zeta, (Iter: zeta_l=%.5f, zeta_u=%.5f, zeta_u-zeta_l=%.5f)\n',zeta,zeta_l,zeta_u,zeta_u-zeta_l);
end

zetaIter(iter)=zeta;
save('mat\SensingSINR.mat','zetaIter');

w_k_1=w_opt;iter=iter+1;

end

%% Plot Figure
% Beampattern_tx
W_opt=reshape(w_opt,N_t,N_t);
TxBp = zeros(size(angleSpace));
for i = 1:length(angleSpace)
    TxBp(i) = abs(a_tx(:,i)' * (W_opt*W_opt') * a_tx(:,i));
end
figure; 
TxBp_l = plot(angleSpaceDeg, mag2db(TxBp), 'LineWidth', 1.5, 'Linestyle', '--'); 
for l=1:L
    tgt_l = line([tgt_agl(l),tgt_agl(l)],[min(mag2db(TxBp)), max(mag2db(TxBp))],'Color', 'black', 'LineWidth', 1.0,'linestyle','--');
end
for k =1:K
    DUE_l = line([DUE_agl(k),DUE_agl(k)],[min(mag2db(TxBp)), max(mag2db(TxBp))],'Color', 'magenta', 'LineWidth', 1.0,'linestyle','--');
end
hold on;
grid on;
xlabel('Angle Space [-90^\circ,90^\circ]');
ylabel('Magnitude (dB)');
title('ISAC Tranmit Beampattern'); 
legend([TxBp_l, tgt_l, DUE_l],'ISAC Tranmit Beampattern','Sensing Direction','Comm Direction'); 
axis([-90, 90, min(mag2db(TxBp)), max(mag2db(TxBp))]);

% Beampattern_rx
% comm
RxBp = zeros(size(angleSpace));
v_u_tmp=[v_m(:,1).' v_m(:,2).' v_m(:,3).' v_m(:,4).'];
v_u=v_u_tmp.';
for i = 1:length(angleSpace)
%     RxBp(i) = abs( v_u'* kron(eye(M),a_rx(:,i)*a_tx(:,i)') * kron(eye(M),W_opt_plot)*...
%         (kron(eye(M),W_opt_plot))'*(kron(eye(M),a_rx(:,i)*a_tx(:,i)'))'*v_u );
     RxBp(i)=abs(a_rx(:,i)' * (W_opt_plot*W_opt_plot') * a_rx(:,i))/sqrt(trace(tilde_W));
end
figure; 
RxBp_l = plot(angleSpaceDeg, mag2db(RxBp), 'LineWidth', 1.5, 'Linestyle', '--');
for l=1:L
    tgt_l = line([tgt_agl(l),tgt_agl(l)],[min(mag2db(RxBp)), max(mag2db(RxBp))],'Color', 'black', 'LineWidth', 1.0,'linestyle','--');
end
for m =1:M
    UUE_l = line([UUE_agl(m),UUE_agl(m)],[min(mag2db(RxBp)), max(mag2db(RxBp))],'Color', 'magenta', 'LineWidth', 1.0,'linestyle','--');
end
hold on;
grid on;
xlabel('Angle Space [-90^\circ,90^\circ]');
ylabel('Magnitude (dB)');
title('Uplink Receive Beampattern'); 
legend([RxBp_l, tgt_l, UUE_l],'Uplink receive Beampattern', 'Sensing Direction', 'Comm Direction'); 
axis([-90, 90, min(mag2db(RxBp)), max(mag2db(RxBp))]);
% sensing


% Conv
% figure
% zeta_24=[7500 6250 6875.00 7187.50 7031.250 6953.1250 6992.18750 7011.718750 7001.9531250 6997.07031250 6994.628906250 6993.4082031250 6992.79785156250 6992.49267578125 6992.64526367188 6992.72155761719 6992.72155761719 6992.72155761719 6992.72155761719 6992.72155761719];
% zeta_20=[7500 6250 5625.00 5312.50 5156.250 5078.1250 5039.06250 5019.531250 5009.7656250 5004.88281250 5002.441406250 5001.2207031250 5000.61035156250 5000.30517578125 5000.15258789063 5000.07629394531 5000.03814697266 5000.03814697266 5000.03814697266 5000.03814697266];
% zeta_16=[2500 1875 2187.50 2343.75 2265.625 2304.6875 2324.21875 2333.984375 2329.1015625 2331.54296875 2330.322265625 2330.9326171875 2331.23779296875 2331.39038085938 2331.31408691406 2331.27593994141 2331.25686645508 2331.24732971191 2331.24256134033 2331.24017715454];
% zeta_24dBm=plot(10*log10(zeta_24),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 'o');
% hold on;
% grid on;
% zeta_20dBm=plot(10*log10(zeta_20),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 's');
% hold on;
% grid on;
% zeta_16dBm=plot(10*log10(zeta_16),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 'd');
% hold on;
% grid on;
% xlabel('Iteration');
% ylabel('Sensing SINR (dB)');
% legend([zeta_24dBm, zeta_20dBm, zeta_16dBm],'P_t=24dBm', 'P_t=20dBm', 'P_t=16dBm');

% tradeoff
% figure;
% SINR_40=[6.46e+07 4.39e+07 3.34e+07 3.13e+07 2.35e+07];
% SINR_30=[1.99e+07 1.73e+07 1.41e+07 1.30e+07 1.24e+07];
% SINR_20=[1.21e+07 1.00e+07 9.08e+06 7.03e+06 6.09e+06];
% SINR_40dBm=plot(10*log10(SINR_40),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 'o');
% hold on;
% grid on;
% SINR_30dBm=plot(10*log10(SINR_30),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 's');
% hold on;
% grid on;
% SINR_20dBm=plot(10*log10(SINR_20),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 'd');
% hold on;
% grid on;
% xlabel('\gamma_{k,d}');
% ylabel('Sensing SINR (dB)');
% legend([SINR_40dBm, SINR_30dBm, SINR_20dBm],'\sigma _{RSI}^2=-40dBm', '\sigma _{RSI}^2=-30dBm', '\sigma _{RSI}^2=-20dBm');

% noma_oma
% noma
% P_H=zeros(N_r,N_r,M);
% for tilde_m=1:M
%     if tilde_m==M
%         P_H(:,:,tilde_m)=zeros(N_r,N_r);
%     end
%     for m=tilde_m+1:M
%         P_H(:,:,tilde_m)=P_H(:,:,tilde_m)+P_u*(h_u(:,m)*h_u(:,m)');
%     end
% end
% SINR_u=zeros(1,4);
% for m=1:M
%     SINR_u(m)=P_u*abs(real(v_m(:,m)'*h_u(:,m)))^2/real( v_m(:,m)'*(P_H(:,:,m)+R_e+R_n+n_u*eye(N_r))*v_m(:,m) );
% end
% oma
% P_H_oma=zeros(N_r,N_r,M);
% for tilde_m=1:M
%     for m=1:M
%         if(m~=tilde_m)
%             P_H_oma(:,:,tilde_m)=P_H(:,:,tilde_m)+P_u*(h_u(:,m)*h_u(:,m)');
%         end
%     end
% end
% SINR_u_oma=zeros(1,4);
% for m=1:M
%     SINR_u_oma(m)=P_u*abs(real(v_m(:,m)'*h_u(:,m)))^2/real( v_m(:,m)'*(P_H_oma(:,:,m)+R_e+R_n+n_u*eye(N_r))*v_m(:,m) );
% end
% figure;
% SINR_u1_noma=[13.98 12.60 11.40 10.60 10.00];
% SINR_u2_noma=[12.40 11.30 10.10 9.20 8.00];
% SINR_u3_noma=[10.96 9.50 8.00 6.60 6.00];
% SINR_u4_noma=[8.80 6.80 5.70 4.90 4.00];
% SINR_u1_oma=[13.98 12.60 11.40 10.60 10.00];
% SINR_u2_oma=[1.66e-03 5.40e-04 5.14e-04 3.00e-04 1.57e-04];
% SINR_u3_oma=[1.53e-04 1.05e-04 2.73e-05 2.31e-05 1.75e-05];
% SINR_u4_oma=[8.01e-06 5.38e-06 1.69e-06 1.51e-06 1.29e-06];
% SINR_u1_noma_dB=plot(10*log10(SINR_u1_noma),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 'o');
% hold on;
% grid on;
% SINR_u2_noma_dB=plot(10*log10(SINR_u2_noma),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 's');
% hold on;
% grid on;
% SINR_u3_noma_dB=plot(10*log10(SINR_u3_noma),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 'd');
% hold on;
% grid on;
% SINR_u4_noma_dB=plot(10*log10(SINR_u4_noma),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', '^');
% hold on;
% grid on;
% SINR_u1_oma_dB=plot(10*log10(SINR_u1_oma),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 'o');
% hold on;
% grid on;
% SINR_u2_oma_dB=plot(10*log10(SINR_u2_oma),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 's');
% hold on;
% grid on;
% SINR_u3_oma_dB=plot(10*log10(SINR_u3_oma),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', 'd');
% hold on;
% grid on;
% SINR_u4_oma_dB=plot(10*log10(SINR_u4_oma),'LineWidth', 1.0, 'Linestyle', '-', 'Marker', '^');
% hold on;
% grid on;
% xlabel('Transmit Power P_t (dBm)');
% ylabel('Uplink Communication SINR (dB)');